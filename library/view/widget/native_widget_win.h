
#ifndef __view_native_widget_win_h__
#define __view_native_widget_win_h__

#pragma once

#include <string>
#include <vector>

#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "base/memory/scoped_vector.h"
#include "base/message_loop.h"
#include "base/win/scoped_comptr.h"
#include "base/win/win_util.h"

#include "ui_base/compositor/compositor.h"
#include "ui_base/win/window_impl.h"

#include "native_widget_private.h"
#include "view/message_crack.h"
#include "view/focus/focus_manager.h"
#include "view/layout/layout_manager.h"

namespace gfx
{
    class CanvasSkia;
    class Font;
    class Rect;
}

namespace ui
{
    class Compositor;
    class ViewProp;
}

namespace view
{

    class DropTargetWin;
    class TooltipManagerWin;

    namespace internal
    {
        class NativeWidgetDelegate;

        // This is exposed only for testing
        // Adjusts the value of |child_rect| if necessary to ensure that it is
        // completely visible within |parent_rect|.
        void EnsureRectIsVisibleInRect(const gfx::Rect& parent_rect,
            gfx::Rect* child_rect, int padding);
    }

    // These two messages aren't defined in winuser.h, but they are sent to windows
    // with captions. They appear to paint the window caption and frame.
    // Unfortunately if you override the standard non-client rendering as we do
    // with CustomFrameWindow, sometimes Windows (not deterministically
    // reproducibly but definitely frequently) will send these messages to the
    // window and paint the standard caption/title over the top of the custom one.
    // So we need to handle these messages in CustomFrameWindow to prevent this
    // from happening.
    const int WM_NCUAHDRAWCAPTION = 0xAE;
    const int WM_NCUAHDRAWFRAME = 0xAF;

    ///////////////////////////////////////////////////////////////////////////////
    //
    // NativeWidgetWin
    //  A Widget for a views hierarchy used to represent anything that can be
    //  contained within an HWND, e.g. a control, a window, etc. Specializations
    //  suitable for specific tasks, e.g. top level window, are derived from this.
    //
    //  This Widget contains a RootView which owns the hierarchy of views within it.
    //  As long as views are part of this tree, they will be deleted automatically
    //  when the RootView is destroyed. If you remove a view from the tree, you are
    //  then responsible for cleaning up after it.
    //
    ///////////////////////////////////////////////////////////////////////////////
    class NativeWidgetWin : public ui::WindowImpl,
        public MessageLoopForUI::Observer,
        public ui::CompositorDelegate,
        public internal::NativeWidgetPrivate
    {
    public:
        NativeWidgetWin(internal::NativeWidgetDelegate* delegate);
        virtual ~NativeWidgetWin();

        // Returns true if we are on Windows Vista or greater and composition is
        // enabled.
        static bool IsAeroGlassEnabled();

        // Returns the system set window title font.
        static gfx::Font GetWindowTitleFont();

        // Show the window with the specified show command.
        void Show(int show_state);

        // Disable Layered Window updates by setting to false.
        void set_can_update_layered_window(bool can_update_layered_window)
        {
            can_update_layered_window_ = can_update_layered_window;
        }

        // Obtain the view event with the given MSAA child id.  Used in
        // NativeViewAccessibilityWin::get_accChild to support requests for
        // children of windowless controls.  May return NULL
        // (see ViewHierarchyChanged).
        View* GetAccessibilityViewEventAt(int id);

        // Add a view that has recently fired an accessibility event.  Returns a MSAA
        // child id which is generated by: -(index of view in vector + 1) which
        // guarantees a negative child id.  This distinguishes the view from
        // positive MSAA child id's which are direct leaf children of views that have
        // associated hWnd's (e.g. NativeWidgetWin).
        int AddAccessibilityViewEvent(View* view);

        // Clear a view that has recently been removed on a hierarchy change.
        void ClearAccessibilityViewEvent(View* view);

        // Hides the window if it hasn't already been force-hidden. The force hidden
        // count is tracked, so calling multiple times is allowed, you just have to
        // be sure to call PopForceHidden the same number of times.
        void PushForceHidden();

        // Decrements the force hidden count, showing the window if we have reached
        // the top of the stack. See PushForceHidden.
        void PopForceHidden();

        BOOL IsWindow() const
        {
            return ::IsWindow(GetNativeView());
        }

        BOOL ShowWindow(int command)
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::ShowWindow(GetNativeView(), command);
        }

        HWND GetParent() const
        {
            return ::GetParent(GetNativeView());
        }

        LONG GetWindowLong(int index)
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::GetWindowLong(GetNativeView(), index);
        }

        BOOL GetWindowRect(RECT* rect) const
        {
            return ::GetWindowRect(GetNativeView(), rect);
        }

        LONG SetWindowLong(int index, LONG new_long)
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::SetWindowLong(GetNativeView(), index, new_long);
        }

        BOOL SetWindowPos(HWND hwnd_after, int x, int y, int cx, int cy, UINT flags)
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::SetWindowPos(GetNativeView(), hwnd_after, x, y, cx, cy, flags);
        }

        BOOL IsZoomed() const
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::IsZoomed(GetNativeView());
        }

        BOOL MoveWindow(int x, int y, int width, int height)
        {
            return MoveWindow(x, y, width, height, TRUE);
        }

        BOOL MoveWindow(int x, int y, int width, int height, BOOL repaint)
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::MoveWindow(GetNativeView(), x, y, width, height, repaint);
        }

        int SetWindowRgn(HRGN region, BOOL redraw)
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::SetWindowRgn(GetNativeView(), region, redraw);
        }

        BOOL GetClientRect(RECT* rect) const
        {
            DCHECK(::IsWindow(GetNativeView()));
            return ::GetClientRect(GetNativeView(), rect);
        }

        // Overridden from ui::CompositorDelegate:
        virtual void ScheduleCompositorPaint();

        // Overridden from internal::NativeWidgetPrivate:
        virtual void InitNativeWidget(const Widget::InitParams& params);
        virtual NonClientFrameView* CreateNonClientFrameView();
        virtual void UpdateFrameAfterFrameChange();
        virtual bool ShouldUseNativeFrame() const;
        virtual void FrameTypeChanged();
        virtual Widget* GetWidget();
        virtual const Widget* GetWidget() const;
        virtual HWND GetNativeView() const;
        virtual HWND GetNativeWindow() const;
        virtual Widget* GetTopLevelWidget();
        virtual const ui::Compositor* GetCompositor() const;
        virtual ui::Compositor* GetCompositor();
        virtual void CalculateOffsetToAncestorWithLayer(
            gfx::Point* offset,
            ui::Layer** layer_parent);
        virtual void ViewRemoved(View* view);
        virtual void SetNativeWindowProperty(const char* name, void* value);
        virtual void* GetNativeWindowProperty(const char* name) const;
        virtual TooltipManager* GetTooltipManager() const;
        virtual bool IsScreenReaderActive() const;
        virtual void SendNativeAccessibilityEvent(View* view,
            ui::AccessibilityTypes::Event event_type);
        virtual void SetMouseCapture();
        virtual void ReleaseMouseCapture();
        virtual bool HasMouseCapture() const;
        virtual InputMethodWin* CreateInputMethod();
        virtual void CenterWindow(const gfx::Size& size);
        virtual void GetWindowPlacement(
            gfx::Rect* bounds,
            ui::WindowShowState* show_state) const;
        virtual void SetWindowTitle(const std::wstring& title);
        virtual void SetWindowIcons(const SkBitmap& window_icon,
            const SkBitmap& app_icon);
        virtual void SetAccessibleName(const std::wstring& name);
        virtual void SetAccessibleRole(ui::AccessibilityTypes::Role role);
        virtual void SetAccessibleState(ui::AccessibilityTypes::State state);
        virtual void BecomeModal();
        virtual gfx::Rect GetWindowScreenBounds() const;
        virtual gfx::Rect GetClientAreaScreenBounds() const;
        virtual gfx::Rect GetRestoredBounds() const;
        virtual void SetBounds(const gfx::Rect& bounds);
        virtual void SetSize(const gfx::Size& size);
        virtual void SetBoundsConstrained(const gfx::Rect& bounds,
            Widget* other_widget);
        virtual void MoveAbove(HWND native_view);
        virtual void MoveToTop();
        virtual void SetShape(HRGN shape);
        virtual void Close();
        virtual void CloseNow();
        virtual void EnableClose(bool enable);
        virtual void Show();
        virtual void Hide();
        virtual void ShowMaximizedWithBounds(
            const gfx::Rect& restored_bounds);
        virtual void ShowWithWindowState(ui::WindowShowState show_state);
        virtual bool IsVisible() const;
        virtual void Activate();
        virtual void Deactivate();
        virtual bool IsActive() const;
        virtual void SetAlwaysOnTop(bool always_on_top);
        virtual void Maximize();
        virtual void Minimize();
        virtual bool IsMaximized() const;
        virtual bool IsMinimized() const;
        virtual void Restore();
        virtual void SetFullscreen(bool fullscreen);
        virtual bool IsFullscreen() const;
        virtual void SetOpacity(unsigned char opacity);
        virtual void SetUseDragFrame(bool use_drag_frame);
        virtual bool IsAccessibleWidget() const;
        virtual void RunShellDrag(View* view,
            const ui::OSExchangeData& data,
            int operation);
        virtual void SchedulePaintInRect(const gfx::Rect& rect);
        virtual void SetCursor(HCURSOR cursor);
        virtual void ClearNativeFocus();
        virtual void FocusNativeView(HWND native_view);
        virtual bool ConvertPointFromAncestor(const Widget* ancestor,
            gfx::Point* point) const;

    protected:
        // Information saved before going into fullscreen mode, used to restore the
        // window afterwards.
        struct SavedWindowInfo
        {
            bool maximized;
            LONG style;
            LONG ex_style;
            RECT window_rect;
        };

        // Overridden from MessageLoop::Observer:
        void WillProcessMessage(const MSG& msg);
        virtual void DidProcessMessage(const MSG& msg);

        // Overridden from WindowImpl:
        virtual HICON GetDefaultWindowIcon() const;
        virtual LRESULT OnWndProc(UINT message, WPARAM w_param, LPARAM l_param);

        // Message Handlers ----------------------------------------------------------
        VIEW_BEGIN_MSG_MAP_EX(NativeWidgetWin)
            // Range handlers must go first!
            VIEW_MESSAGE_RANGE_HANDLER_EX(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseRange)
            VIEW_MESSAGE_RANGE_HANDLER_EX(WM_NCMOUSEMOVE, WM_NCXBUTTONDBLCLK, OnMouseRange)

            // Reflected message handler
            VIEW_MESSAGE_HANDLER_EX(base::win::kReflectedMessage, OnReflectedMessage)

            // CustomFrameWindow hacks
            VIEW_MESSAGE_HANDLER_EX(WM_NCUAHDRAWCAPTION, OnNCUAHDrawCaption)
            VIEW_MESSAGE_HANDLER_EX(WM_NCUAHDRAWFRAME, OnNCUAHDrawFrame)

            // Vista and newer
            VIEW_MESSAGE_HANDLER_EX(WM_DWMCOMPOSITIONCHANGED, OnDwmCompositionChanged)

            // Non-atlcrack.h handlers
            VIEW_MESSAGE_HANDLER_EX(WM_GETOBJECT, OnGetObject)

            // Mouse events.
            VIEW_MESSAGE_HANDLER_EX(WM_MOUSEACTIVATE, OnMouseActivate)
            VIEW_MESSAGE_HANDLER_EX(WM_MOUSELEAVE, OnMouseRange)
            VIEW_MESSAGE_HANDLER_EX(WM_NCMOUSELEAVE, OnMouseRange)
            VIEW_MSG_WM_SETCURSOR(OnSetCursor)

            // Key events.
            VIEW_MESSAGE_HANDLER_EX(WM_KEYDOWN, OnKeyEvent)
            VIEW_MESSAGE_HANDLER_EX(WM_KEYUP, OnKeyEvent)
            VIEW_MESSAGE_HANDLER_EX(WM_SYSKEYDOWN, OnKeyEvent);
            VIEW_MESSAGE_HANDLER_EX(WM_SYSKEYUP, OnKeyEvent);

            // IME Events.
            VIEW_MESSAGE_HANDLER_EX(WM_IME_SETCONTEXT, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_IME_STARTCOMPOSITION, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_IME_COMPOSITION, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_IME_ENDCOMPOSITION, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_IME_NOTIFY, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_CHAR, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_SYSCHAR, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_DEADCHAR, OnImeMessages)
            VIEW_MESSAGE_HANDLER_EX(WM_SYSDEADCHAR, OnImeMessages)

            // This list is in _ALPHABETICAL_ order! OR I WILL HURT YOU.
            VIEW_MSG_WM_ACTIVATE(OnActivate)
            VIEW_MSG_WM_ACTIVATEAPP(OnActivateApp)
            VIEW_MSG_WM_APPCOMMAND(OnAppCommand)
            VIEW_MSG_WM_CANCELMODE(OnCancelMode)
            VIEW_MSG_WM_CAPTURECHANGED(OnCaptureChanged)
            VIEW_MSG_WM_CLOSE(OnClose)
            VIEW_MSG_WM_COMMAND(OnCommand)
            VIEW_MSG_WM_CREATE(OnCreate)
            VIEW_MSG_WM_DESTROY(OnDestroy)
            VIEW_MSG_WM_DISPLAYCHANGE(OnDisplayChange)
            VIEW_MSG_WM_ERASEBKGND(OnEraseBkgnd)
            VIEW_MSG_WM_ENDSESSION(OnEndSession)
            VIEW_MSG_WM_ENTERSIZEMOVE(OnEnterSizeMove)
            VIEW_MSG_WM_EXITMENULOOP(OnExitMenuLoop)
            VIEW_MSG_WM_EXITSIZEMOVE(OnExitSizeMove)
            VIEW_MSG_WM_GETMINMAXINFO(OnGetMinMaxInfo)
            VIEW_MSG_WM_HSCROLL(OnHScroll)
            VIEW_MSG_WM_INITMENU(OnInitMenu)
            VIEW_MSG_WM_INITMENUPOPUP(OnInitMenuPopup)
            VIEW_MSG_WM_INPUTLANGCHANGE(OnInputLangChange)
            VIEW_MSG_WM_KILLFOCUS(OnKillFocus)
            VIEW_MSG_WM_MOVE(OnMove)
            VIEW_MSG_WM_MOVING(OnMoving)
            VIEW_MSG_WM_NCACTIVATE(OnNCActivate)
            VIEW_MSG_WM_NCCALCSIZE(OnNCCalcSize)
            VIEW_MSG_WM_NCHITTEST(OnNCHitTest)
            VIEW_MSG_WM_NCPAINT(OnNCPaint)
            VIEW_MSG_WM_NOTIFY(OnNotify)
            VIEW_MSG_WM_PAINT(OnPaint)
            VIEW_MSG_WM_POWERBROADCAST(OnPowerBroadcast)
            VIEW_MSG_WM_SETFOCUS(OnSetFocus)
            VIEW_MSG_WM_SETICON(OnSetIcon)
            VIEW_MSG_WM_SETTEXT(OnSetText)
            VIEW_MSG_WM_SETTINGCHANGE(OnSettingChange)
            VIEW_MSG_WM_SIZE(OnSize)
            VIEW_MSG_WM_SYSCOMMAND(OnSysCommand)
            VIEW_MSG_WM_THEMECHANGED(OnThemeChanged)
            VIEW_MSG_WM_VSCROLL(OnVScroll)
            VIEW_MSG_WM_WINDOWPOSCHANGING(OnWindowPosChanging)
            VIEW_MSG_WM_WINDOWPOSCHANGED(OnWindowPosChanged)
        VIEW_END_MSG_MAP()

            // These are all virtual so that specialized Widgets can modify or augment
            // processing.
            // This list is in _ALPHABETICAL_ order!
            // Note: in the base class these functions must do nothing but convert point
            //       coordinates to client coordinates (if necessary) and forward the
            //       handling to the appropriate Process* function. This is so that
            //       subclasses can easily override these methods to do different things
            //       and have a convenient function to call to get the default behavior.
        virtual void OnActivate(UINT action, BOOL minimized, HWND window);
        virtual void OnActivateApp(BOOL active, DWORD thread_id);
        virtual LRESULT OnAppCommand(HWND window, short app_command, WORD device,
            int keystate);
        virtual void OnCancelMode();
        virtual void OnCaptureChanged(HWND hwnd);
        virtual void OnClose();
        virtual void OnCommand(UINT notification_code, int command_id, HWND window);
        virtual LRESULT OnCreate(CREATESTRUCT* create_struct);
        // WARNING: If you override this be sure and invoke super, otherwise we'll
        // leak a few things.
        virtual void OnDestroy();
        virtual void OnDisplayChange(UINT bits_per_pixel, gfx::Size screen_size);
        virtual LRESULT OnDwmCompositionChanged(UINT msg, WPARAM w_param, LPARAM l_param);
        virtual void OnEndSession(BOOL ending, UINT logoff);
        virtual void OnEnterSizeMove();
        virtual LRESULT OnEraseBkgnd(HDC dc);
        virtual void OnExitMenuLoop(BOOL is_track_popup_menu);
        virtual void OnExitSizeMove();
        virtual LRESULT OnGetObject(UINT uMsg, WPARAM w_param, LPARAM l_param);
        virtual void OnGetMinMaxInfo(MINMAXINFO* minmax_info);
        virtual void OnHScroll(int scroll_type, short position, HWND scrollbar);
        virtual LRESULT OnImeMessages(UINT message, WPARAM w_param, LPARAM l_param);
        virtual void OnInitMenu(HMENU menu);
        virtual void OnInitMenuPopup(HMENU menu, UINT position, BOOL is_system_menu);
        virtual void OnInputLangChange(DWORD character_set, HKL input_language_id);
        virtual LRESULT OnKeyEvent(UINT message, WPARAM w_param, LPARAM l_param);
        virtual void OnKillFocus(HWND focused_window);
        virtual LRESULT OnMouseActivate(UINT message, WPARAM w_param, LPARAM l_param);
        virtual LRESULT OnMouseRange(UINT message, WPARAM w_param, LPARAM l_param);
        virtual void OnMove(const gfx::Point& point);
        virtual void OnMoving(UINT param, LPRECT new_bounds);
        virtual LRESULT OnNCActivate(BOOL active);
        virtual LRESULT OnNCCalcSize(BOOL mode, LPARAM l_param);
        virtual LRESULT OnNCHitTest(const gfx::Point& pt);
        virtual void OnNCPaint(HRGN rgn);
        virtual LRESULT OnNCUAHDrawCaption(UINT msg, WPARAM w_param, LPARAM l_param);
        virtual LRESULT OnNCUAHDrawFrame(UINT msg, WPARAM w_param, LPARAM l_param);
        virtual LRESULT OnNotify(int w_param, NMHDR* l_param);
        virtual void OnPaint(HDC dc);
        virtual LRESULT OnPowerBroadcast(DWORD power_event, DWORD data);
        virtual LRESULT OnReflectedMessage(UINT msg, WPARAM w_param, LPARAM l_param);
        virtual LRESULT OnSetCursor(HWND window, UINT hit_test, UINT message);
        virtual void OnSetFocus(HWND focused_window);
        virtual LRESULT OnSetIcon(UINT size_type, HICON new_icon);
        virtual LRESULT OnSetText(const wchar_t* text);
        virtual void OnSettingChange(UINT flags, const wchar_t* section);
        virtual void OnSize(UINT param, const gfx::Size& size);
        virtual void OnSysCommand(UINT notification_code, gfx::Point click);
        virtual void OnThemeChanged();
        virtual void OnVScroll(int scroll_type, short position, HWND scrollbar);
        virtual void OnWindowPosChanging(WINDOWPOS* window_pos);
        virtual void OnWindowPosChanged(WINDOWPOS* window_pos);

        // Deletes this window as it is destroyed, override to provide different
        // behavior.
        virtual void OnFinalMessage(HWND window);

        // Retrieve the show state of the window. This is one of the SW_SHOW* flags
        // passed into Windows' ShowWindow method. For normal windows this defaults
        // to SW_SHOWNORMAL, however windows (e.g. the main window) can override this
        // method to provide different values (e.g. retrieve the user's specified
        // show state from the shortcut starutp info).
        virtual int GetShowState() const;

        // Returns the insets of the client area relative to the non-client area of
        // the window. Override this function instead of OnNCCalcSize, which is
        // crazily complicated.
        virtual gfx::Insets GetClientAreaInsets() const;

        // Start tracking all mouse events so that this window gets sent mouse leave
        // messages too.
        void TrackMouseEvents(DWORD mouse_tracking_flags);

        // Called when a MSAA screen reader client is detected.
        virtual void OnScreenReaderDetected();

        // Executes the specified SC_command.
        void ExecuteSystemMenuCommand(int command);

        // The TooltipManager.
        // WARNING: RootView's destructor calls into the TooltipManager. As such, this
        // must be destroyed AFTER root_view_.
        scoped_ptr<TooltipManagerWin> tooltip_manager_;

        scoped_refptr<DropTargetWin> drop_target_;

        // Are a subclass of WindowWin?
        bool is_window_;

        const gfx::Rect& invalid_rect() const { return invalid_rect_; }

        // Saved window information from before entering fullscreen mode.
        // TODO(beng): move to private once GetRestoredBounds() moves onto Widget.
        SavedWindowInfo saved_window_info_;

    private:
        typedef ScopedVector<ui::ViewProp> ViewProps;

        // Called after the WM_ACTIVATE message has been processed by the default
        // windows procedure.
        static void PostProcessActivateMessage(NativeWidgetWin* widget,
            int activation_state);

        void SetInitParams(const Widget::InitParams& params);

        // Synchronously paints the invalid contents of the Widget.
        void RedrawInvalidRect();

        // Synchronously updates the invalid contents of the Widget. Valid for
        // layered windows only.
        void RedrawLayeredWindowContents();

        // Lock or unlock the window from being able to redraw itself in response to
        // updates to its invalid region.
        class ScopedRedrawLock;
        void LockUpdates();
        void UnlockUpdates();

        // Determines whether the delegate expects the client size or the window size.
        bool WidgetSizeIsClientSize() const;

        // Responds to the client area changing size, either at window creation time
        // or subsequently.
        void ClientAreaSizeChanged();

        // Resets the window region for the current widget bounds if necessary.
        // If |force| is true, the window region is reset to NULL even for native
        // frame windows.
        void ResetWindowRegion(bool force);

        // Calls the default WM_NCACTIVATE handler with the specified activation
        // value, safely wrapping the call in a ScopedRedrawLock to prevent frame
        // flicker.
        LRESULT CallDefaultNCActivateHandler(BOOL active);

        // Stops ignoring SetWindowPos() requests (see below).
        void StopIgnoringPosChanges() { ignore_window_pos_changes_ = false; }

        void RestoreEnabledIfNecessary();

         void SetInitialFocus();

        // A delegate implementation that handles events received here.
        // See class documentation for Widget in widget.h for a note about ownership.
        internal::NativeWidgetDelegate* delegate_;

        // The following factory is used for calls to close the NativeWidgetWin
        // instance.
        ScopedRunnableMethodFactory<NativeWidgetWin> close_widget_factory_;

        // The flags currently being used with TrackMouseEvent to track mouse
        // messages. 0 if there is no active tracking. The value of this member is
        // used when tracking is canceled.
        DWORD active_mouse_tracking_flags_;

        // Should we keep an off-screen buffer? This is false by default, set to true
        // when WS_EX_LAYERED is specified before the native window is created.
        //
        // NOTE: this is intended to be used with a layered window (a window with an
        // extended window style of WS_EX_LAYERED). If you are using a layered window
        // and NOT changing the layered alpha or anything else, then leave this value
        // alone. OTOH if you are invoking SetLayeredWindowAttributes then you'll
        // most likely want to set this to false, or after changing the alpha toggle
        // the extended style bit to false than back to true. See MSDN for more
        // details.
        bool use_layered_buffer_;

        // The default alpha to be applied to the layered window.
        BYTE layered_alpha_;

        // A canvas that contains the window contents in the case of a layered
        // window.
        scoped_ptr<gfx::CanvasSkia> layered_window_contents_;

        // We must track the invalid rect ourselves, for two reasons:
        // For layered windows, Windows will not do this properly with
        // InvalidateRect()/GetUpdateRect(). (In fact, it'll return misleading
        // information from GetUpdateRect()).
        // We also need to keep track of the invalid rectangle for the RootView should
        // we need to paint the non-client area. The data supplied to WM_NCPAINT seems
        // to be insufficient.
        gfx::Rect invalid_rect_;

        // A factory that allows us to schedule a redraw for layered windows.
        ScopedRunnableMethodFactory<NativeWidgetWin> paint_layered_window_factory_;

        // See class documentation for Widget in widget.h for a note about ownership.
        Widget::InitParams::Ownership ownership_;

        // True if we are allowed to update the layered window from the DIB backing
        // store if necessary.
        bool can_update_layered_window_;

        // Whether the focus should be restored next time we get enabled.  Needed to
        // restore focus correctly when Windows modal dialogs are displayed.
        bool restore_focus_when_enabled_;

        // Instance of accessibility information and handling for MSAA root
        base::win::ScopedComPtr<IAccessible> accessibility_root_;

        // Value determines whether the Widget is customized for accessibility.
        static bool screen_reader_active_;

        // The maximum number of view events in our vector below.
        static const int kMaxAccessibilityViewEvents = 20;

        // A vector used to access views for which we have sent notifications to
        // accessibility clients.  It is used as a circular queue.
        std::vector<View*> accessibility_view_events_;

        // The current position of the view events vector.  When incrementing,
        // we always mod this value with the max view events above .
        int accessibility_view_events_index_;

        // The last cursor that was active before the current one was selected. Saved
        // so that we can restore it.
        HCURSOR previous_cursor_;

        ViewProps props_;

        // True if we're in fullscreen mode.
        bool fullscreen_;

        // If this is greater than zero, we should prevent attempts to make the window
        // visible when we handle WM_WINDOWPOSCHANGING. Some calls like
        // ShowWindow(SW_RESTORE) make the window visible in addition to restoring it,
        // when all we want to do is restore it.
        int force_hidden_count_;

        // The window styles before we modified them for the drag frame appearance.
        DWORD drag_frame_saved_window_style_;
        DWORD drag_frame_saved_window_ex_style_;

        // Represents the number of ScopedRedrawLocks active against this widget.
        // If this is greater than zero, the widget should be locked against updates.
        int lock_updates_count_;

        // The window styles of the window before updates were locked.
        DWORD saved_window_style_;

        // When true, this flag makes us discard incoming SetWindowPos() requests that
        // only change our position/size.  (We still allow changes to Z-order,
        // activation, etc.)
        bool ignore_window_pos_changes_;

        // The following factory is used to ignore SetWindowPos() calls for short time
        // periods.
        ScopedRunnableMethodFactory<NativeWidgetWin> ignore_pos_changes_factory_;

        // The last-seen monitor containing us, and its rect and work area.  These are
        // used to catch updates to the rect and work area and react accordingly.
        HMONITOR last_monitor_;
        gfx::Rect last_monitor_rect_, last_work_area_;

        // Set to true when the user presses the right mouse button on the caption
        // area. We need this so we can correctly show the context menu on mouse-up.
        bool is_right_mouse_pressed_on_caption_;

        // Whether all ancestors have been enabled. This is only used if is_modal_ is
        // true.
        bool restored_enabled_;

        // The compositor for accelerated drawing.
        scoped_refptr<ui::Compositor> compositor_;

        // TODO(msw): Remove debugging code for crbug.com/95727
        bool* destroyed_;

        DISALLOW_COPY_AND_ASSIGN(NativeWidgetWin);
    };

} //namespace view

#endif //__view_native_widget_win_h__